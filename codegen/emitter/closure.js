/**
 * @fileoverview Provides emitter class that can emit JS code compatible with
 * Google closure compiler based on the nodes generated by the different
 * parsers.
 *
 * @author regardingscot@gmail.com (PeterStJ)
 */
goog.provide('pstj.codegen.emitter.Closure');

goog.require('goog.array');
goog.require('goog.object');
goog.require('goog.string');
goog.require('pstj.codegen.node.jstype');
goog.require('pstj.codegen.node.type');
goog.require('pstj.sourcegen.JavascriptBuffer');


pstj.codegen.emitter.Closure = class {
  constructor() {
    /** @protected {?pstj.codegen.node.Document} */
    this.document = null;
    /**
     * The buffer we will be using to create the code.
     * @protected {!pstj.sourcegen.JavascriptBuffer}
     */
    this.buffer = new pstj.sourcegen.JavascriptBuffer();
    /** @private {string} The namespace to use. */
    this.autogenNamespace_ = 'app.gen';
    /** @private {string} The namespace for the DTO classes */
    this.dtonamespace_ = this.autogenNamespace_ + '.dto';
    /** @protected {string} The base class for DTO classes */
    this.dtoExtendClass = 'pstj.ds.DtoBase';
  }


  /**
   * Allows to use custom namespace for generated code.
   *
   * @param {string} ns The namespace to use.
   */
  setAutogenNamespace(ns) {
    this.autogenNamespace_ = ns;
    this.dtonamespace_ = `${this.autogenNamespace_}.dto`;
  }


  /**
   * Adds a new namespace as provided in the file.
   * @protected
   * @param {string} namespace
   */
  addProvide(namespace) {
    this.buffer.writeln(`goog.provide('${namespace}');`);
  }


  /**
   * Adds a new namespace as a required in the file.
   * @protected
   * @param {string} namespace
   */
  addRequire(namespace) {
    this.buffer.writeln(`goog.require('${namespace}');`);
  }


  /**
   * Loads a document to setup the emitting.
   *
   * @param {!pstj.codegen.node.Document} doc
   */
  setDocument(doc) { this.document = doc; }


  /**
   * Generates code for a specific document.
   *
   * @return {string}
   */
  generateCode() {
    if (goog.isNull(this.document))
      throw new Error('Cannot generate code without input document.');
    this.generateDtoClassesProvides();
    this.generateDtoClasses();
    return this.buffer.toString();
  }


  /**
   * Iterate over the classes in the document and generate code for them.
   * @protected
   */
  generateDtoClasses() {
    goog.object.forEach(this.document.classes, this.generateDtoClass, this);
  }


  /**
   * @protected
   * @param {!pstj.codegen.node.Class} cl
   */
  generateDtoClass(cl) {
    if (this.hasValidDescription(cl)) {
      this.buffer.startComment();
      this.buffer.writeComment(cl.description);
      this.buffer.endComment();
    }
    this.buffer.startClassDefinition(
        `${this.dtonamespace_}.${cl.name}`, this.dtoExtendClass);
    this.buffer.startMethodDefinition('constructor');
    goog.array.forEach(cl.properties, this.generatePropertyDefinition, this);
    this.buffer.endMethodDefinition();
    this.buffer.endClassDefinition();
  }


  /**
   * Adds all DTO classes as provides for the compiler.
   * @protected
   */
  generateDtoClassesProvides() {
    goog.object.forEach(this.document.classes, item => {
      this.addProvide(`${this.dtonamespace_}.${item.name}`);
    }, this);
  }


  /**
   * Checks if the description field is valid.
   *
   * @protected
   * @param {!pstj.codegen.node.Node} node
   * @return {boolean}
   */
  hasValidDescription(node) {
    return !goog.string.isEmptyOrWhitespace(node.description);
  }


  /**
   * Generates a property in the class constructor.
   *
   * @protected
   * @param {!pstj.codegen.node.Property} property
   */
  generatePropertyDefinition(property) {
    let jsDoc = this.buffer.createComment(
        'type', undefined, this.getPropertyAnnotationType(property));
    if (this.hasValidDescription(property)) {
      this.buffer.startComment();
      this.buffer.writeComment(property.description);
      this.buffer.lines(1);
      this.buffer.writeComment(jsDoc);
      this.buffer.endComment();
    } else {
      this.buffer.writeSingleLineComment(jsDoc);
    }

    let name = this.getPropertyName(property);
    let defaultValue = this.getPropertyDefaultvalue(property);
    this.buffer.writeln(`this.${name} = ${defaultValue};`);
  }


  /**
   * Extracts the desired property name. Note that in Sysmaster format we can
   * have a desired property name and might not want to use the name provided by
   * the server descriptor.
   *
   * @protected
   * @param {!pstj.codegen.node.Property} property
   * @return {string}
   */
  getPropertyName(property) {
    if (!goog.isNull(property.desiredName)) return property.desiredName;
    return property.name;
  }


  /**
   * Extracted getter for the property type. We need this as Sysmaster can
   * provide custom names for properties.
   *
   * @protected
   * @param {!pstj.codegen.node.Property} property
   * @return {!pstj.codegen.node.type}
   */
  getPropertyType(property) {
    if (!goog.isNull(property.desiredType)) return property.desiredType;
    return property.type;
  }


  /**
   * Generates the default value based on the property type.
   *
   * @protected
   * @param {!pstj.codegen.node.Property} property
   * @return {string}
   */
  getPropertyDefaultvalue(property) {
    let jstype =
        this.determineJsType(this.getPropertyType(property), null, property);
    switch (jstype) {
      case pstj.codegen.node.jstype.BOOLEAN:
        return 'false';
      case pstj.codegen.node.jstype.STRING:
        return '\'\'';
      case pstj.codegen.node.jstype.NUMBER:
        // Consider floats (0.0)
        return '0';
      case pstj.codegen.node.jstype.DATE:
        if (property.required) {
          return 'new Date()';
        } else
          return 'null';
      case pstj.codegen.node.jstype.ARRAY:
        if (property.required)
          return '[]';
        else
          return 'null';
      case pstj.codegen.node.jstype.REFERENCE:
        if (property.required)
          return `new ${this.dtonamespace_}.${property.referredType}()`;
        else
          return 'null';
      default:
        throw new Error('Unhandled default type');
    }
  }


  /**
   * Given a type and format attempts to determine which JS type should be
   * used to represent correctly the transferable.
   *
   * @protected
   * @param {pstj.codegen.node.type} type
   * @param {?pstj.codegen.node.format} format
   * @param {?pstj.codegen.node.Property=} opt_prop
   * @return {pstj.codegen.node.jstype}
   */
  determineJsType(type, format, opt_prop) {
    if (type == pstj.codegen.node.type.OBJECT) {
      if (goog.isDefAndNotNull(opt_prop)) {
        if (opt_prop.type != type) {
          // we must be a date then...
          return pstj.codegen.node.jstype.DATE;
        }
      }
      return pstj.codegen.node.jstype.REFERENCE;
    }
    if (type == pstj.codegen.node.type.INT) {
      // 64 bit numbers cannot be represented as numbers in JS, we use them as
      // strings.
      if (format == pstj.codegen.node.format.INT64)
        return pstj.codegen.node.jstype.STRING;
      else
        return pstj.codegen.node.jstype.NUMBER;
    }
    // float and double are always numbers and we always use 0.0 as default.
    if (type == pstj.codegen.node.type.NUMBER)
      return pstj.codegen.node.jstype.NUMBER;
    if (type == pstj.codegen.node.type.STRING) {
      if (!goog.isNull(format)) {
        if (format == pstj.codegen.node.format.DATE ||
            format == pstj.codegen.node.format.DATETIME) {
          return pstj.codegen.node.jstype.DATE;
        } else {
          // Consider adding support for BYTE (Signed int array) and
          // binary (typed array?)
          return pstj.codegen.node.jstype.STRING;
        }
      } else {
        return pstj.codegen.node.jstype.STRING;
      }
    }
    if (type == pstj.codegen.node.type.BOOLEAN)
      return pstj.codegen.node.jstype.BOOLEAN;
    if (type == pstj.codegen.node.type.ARRAY)
      return pstj.codegen.node.jstype.ARRAY;
    throw new Error('No matching type: ' + type);
  }


  /**
   * Prepares and returns propertly structured annotation for the type of the
   * property.
   *
   * @protected
   * @param {!pstj.codegen.node.Property} property
   * @return {string}
   */
  getPropertyAnnotationType(property) {
    let type = this.getPropertyType(property);
    let jstype = this.determineJsType(type, property.format, property);
    switch (jstype) {
      case pstj.codegen.node.jstype.NUMBER:
        return 'number';
      case pstj.codegen.node.jstype.STRING:
        return 'string';
      case pstj.codegen.node.jstype.BOOLEAN:
        return 'boolean';
      case pstj.codegen.node.jstype.ARRAY:
        let type = this.getArrayType(property);
        return 'Array<' + (this.isNonNullableArrayType(type) ? '!' : '') +
            type + '>';
      case pstj.codegen.node.jstype.DATE:
        return 'Date';
      case pstj.codegen.node.jstype.REFERENCE:
        // check if the class reference exists and only then add it.
        if (goog.object.containsKey(
                this.document.classes, property.referredType)) {
          return `${this.dtonamespace_}.${property.referredType}`;
        } else
          throw new Error(
              'The referred type cannot be found: ' + property.referredType);
      default:
        throw new Error('Unsupported type: ' + type);
    }
  }

  /**
   * Given a type of JS return its string representation. Useful to convert
   * enum jstype to type that can be printed.
   *
   * @protected
   * @param {pstj.codegen.node.jstype} jsType
   * @return {string}
   */
  convertJsTypeToString(jsType) {
    switch (jsType) {
      case pstj.codegen.node.jstype.NUMBER:
        return 'number';
      case pstj.codegen.node.jstype.STRING:
        return 'string';
      case pstj.codegen.node.jstype.BOOLEAN:
        return 'boolean';
      case pstj.codegen.node.jstype.DATE:
        return 'Date';
    }
  }


  /**
   * Determines if the array type needs to be non-nullable.
   *
   * By default for closure code array primitive types do not need to be
   * defined as non-nullable, so all primitives we return false (i.e
   * do not need `!`). Non-primitives in array are always non-null (dense
   * arrays).
   *
   * @param {!pstj.codegen.node.jstype} jstype
   * @return {boolean}
   */
  isNonNullableArrayType(jstype) {
    switch (jstype) {
      case pstj.codegen.node.jstype.NUMBER:
      case pstj.codegen.node.jstype.STRING:
      case pstj.codegen.node.jstype.BOOLEAN:
        return false;
      default:
        return true;
    }
  }


  /**
   * Extracts the type of the array. Note that we will always assume dense
   * arrays.
   *
   * @protected
   * @param {!pstj.codegen.node.Property} property
   * @return {!pstj.codegen.node.jstype}
   */
  getArrayType(property) {
    if (property.type != pstj.codegen.node.type.ARRAY)
      throw new Error('Property is not an array');
    if (property.itemType == pstj.codegen.node.type.UNKNOWN)
      throw new Error('Property array item type is unknown');
    return this.determineJsType(property.itemType, null);
  }
};